# Quality control

Not all pixels in a MODIS land product image can be used for analysis. For example, some pixels may by cloudy such that the land area was not observed. For that reason, each image needs to be pre-processed to remove low quality pixels. 

To do so, we can create a "mask" that identifies the pixels affected by, for example, clouds, and shadows. Fortunately, the quality of each pixel has been assessed for us, and the results, are made available together with the reflectance data. Unfortunately, the way this quality assessment (QA) is made available is a bit complicated --- the information it is highly compressed in order to not use much disk space. Several observations are stored as 1, 2, or 4 bit values (a bit can be either a zero or a one, so with 2 bits you can identify four cases (00, 01, 10, 11). These values are appended into a single 32 bit value. 

The table below indicates what it stored in each set of bits (for 500 m, 1 km and lower resolution MODIS surface reflectance data).

```{r StateQA, echo=FALSE}
table <- read.table("MODIS_State_QA.txt", header=TRUE, sep = "\t", colClasses = "character", encoding ="UTF-8")
dm <- data.frame(table, stringsAsFactors = FALSE)
colnames(dm) <- c("bit", "variable", "value", "description")
dm[,4] = gsub("\n", " ", dm[,4])
knitr::kable(dm, align="l")
```

Note that the first bit is referred as "1". That may seem obvious, but in other documentation, "0" may be used as the position of the first bit. In the luna package it is always "1". 

The `luna` package has a function to create a mask from the QA data. You need to specify a matrix ("qabits") with the start and end of the quality assessment (QA) bits considered, and specify a list ("reject") with the values to be rejected (in the image) matching the rows in `qabits`.

```{r qcconst}
from <- c(1,3,11,12) #,16)
to   <- c(2,6,11,14) #,17)
reject <- c("10,11", "1100,1101,1110,1111", "1", "000,110,111")

qa_bits <- cbind(from, to, reject)
qa_bits
```

Thus, if bits 1 and 2 have values "10" or "11", these are rejected. All other combinations ("00" and "01" in this case) are not rejected.

We use the downloaded MODIS file that, in a previouse step, we saved in the `datadir` directory.

```{r mod, message=FALSE}
library(terra)
datadir <- file.path(dirname(tempdir()), "modis")
mf <- file.path(datadir, "MOD09A1.A2009361.h21v08.006.2015198070255.hdf")

r <- rast(mf)
```

Generate the quality mask. We will use band 12 `sur_refl_state_500m` that has the quality data.

```{r qc1}
qc <- r[[12]]

plot(qc, main = "Quality")
```

The luna package has the `modis_mask` method creates a mask from the quality band and the parameters defined above. 

```{r qc2}
library(luna)

quality_mask <- modis_mask(qc, 16, qa_bits)

plot(quality_mask, main="Quality mask")  
```

The plot shows the pixels we want to retain. Now that we have the quality mask, we can apply it to all the bands. 

```{r qcmask}
rmask <- mask(r, quality_mask)
```

And we can plot the results, here as a "false color composite" (NIR:Red:Green)

```{r qcmaskplot}
plotRGB(rmask, r = 2, g = 1, b = 4, main='False color composite', stretch="lin")
```

Finally we save the result after cloud masking.

```{r savefile, echo=FALSE}
mf <- file.path(datadir, "modis_qualmasked.tif")

writeRaster(rmask, mf, overwrite=TRUE)
```

